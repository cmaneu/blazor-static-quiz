@using BlazorQuiz.Model
@using System.Threading


@if (CurrentQuestion.TimeLimit != 0)
{
    <p>
        <span class="badge badge-light"> Time Remaining: <strong>@countDown</strong> seconds</span>
    </p>
}



@code {

    [Parameter]
    public Question CurrentQuestion { get; set; }

    [Parameter]
    public int DefaultTimeLimit { get; set; }

    [Parameter]
    public EventCallback<EventArgs> OnQuestionTimeOut { get; set; }

    private int currentQuestionId;

    private int countDown = 0;

    private Task _countdownTask;

    private CancellationTokenSource _cts;

    protected override async void OnParametersSet()
    {
        // If parameter get updated for the same question, ignore.
        if (CurrentQuestion.Id == currentQuestionId)
            return;

        currentQuestionId = CurrentQuestion.Id;

        StateHasChanged();


        if (CurrentQuestion.TimeLimit == default(int))
            return;

        countDown = CurrentQuestion.TimeLimit + 1;
        StartTimer();

    }

    async Task StartTimer()
    {
        _cts?.Cancel();

        _cts = new CancellationTokenSource();

        TimerLoop(_cts.Token);

        //waitingEvent.Reset();
        //bool isQuestionAnswered = waitingEvent.Wait(CurrentQuestion.TimeLimit * 1000);

        //if (!isQuestionAnswered)
        //{
        //    await OnQuestionTimeOut.InvokeAsync(null);
        //}
    }


    async Task TimerLoop(CancellationToken ctsToken)
    {
        var startQuestionId = CurrentQuestion?.Id;

        while (CurrentQuestion != null && countDown > 0)
        {
            if(ctsToken.IsCancellationRequested)
                return;

            // TODO: Fix this. This is horrible. Sorry.
            //if (startQuestionId != CurrentQuestion.Id)
            //{
            //    countDown = 0;
            //    return;
            //}

            countDown -= 1;
            StateHasChanged();

            if (countDown <= 0)
            {
                await OnQuestionTimeOut.InvokeAsync(null);
                StateHasChanged();
                return;
            }

            await Task.Delay(1000);
        }
    }
}
